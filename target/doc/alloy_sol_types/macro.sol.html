<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parses Solidity syntax to generate types that implement `alloy-sol-types` traits."><title>sol in alloy_sol_types - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="alloy_sol_types" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../alloy_sol_types/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../alloy_sol_types/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In alloy_sol_types</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">alloy_sol_types</a>::<wbr><a class="macro" href="#">sol</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/alloy_sol_macro/lib.rs.html#67">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>sol!() { /* proc-macro */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parses Solidity syntax to generate types that implement <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a>
traits.</p>
<p>These types may then be used for safe <a href="https://docs.soliditylang.org/en/latest/abi-spec.html">ABI</a> and <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a> encoding and
decoding.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Note: the following examples cannot be tested here because the generated
code references <code>alloy-sol-types</code>, so they are [tested in that crate]
<a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types/tests/">tests</a> and included with <code>include_str!</code> in this doc instead.</p>
<h3 id="structs-and-enums"><a href="#structs-and-enums">Structs and enums</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{Address, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolType};
<span class="kw">use </span>hex_literal::hex;

<span class="comment">// Struct definitions will generate a struct with the same name and fields.
// No casing convention is enforced.
</span><span class="macro">sol! </span>{
    <span class="kw">struct </span>Foo {
        uint256 bar;
        address[] baz;
    }

    <span class="doccomment">/// Nested struct.
    </span><span class="kw">struct </span>Nested {
        Foo[<span class="number">2</span>] a;
        address b;
    }

    <span class="comment">// TODO: enums
    /*
    enum Enum {
        A,
        B,
        C,
    }
    */
</span>}

<span class="attr">#[test]
</span><span class="kw">fn </span>structs() {
    <span class="kw">let </span>my_foo = Foo {
        bar: U256::from(<span class="number">42</span>),
        baz: <span class="macro">vec!</span>[Address::repeat_byte(<span class="number">0x11</span>), Address::repeat_byte(<span class="number">0x22</span>)],
    };

    <span class="kw">let </span>_nested = Nested {
        a: [my_foo.clone(), my_foo.clone()],
        b: Address::ZERO,
    };

    <span class="kw">let </span>abi_encoded = Foo::encode(<span class="kw-2">&amp;</span>my_foo);
    <span class="macro">assert_eq!</span>(
        abi_encoded,
        <span class="macro">hex! </span>{
            <span class="string">&quot;000000000000000000000000000000000000000000000000000000000000002a&quot; </span><span class="comment">// bar
            </span><span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000040&quot; </span><span class="comment">// baz offset
            </span><span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000002&quot; </span><span class="comment">// baz length
            </span><span class="string">&quot;0000000000000000000000001111111111111111111111111111111111111111&quot; </span><span class="comment">// baz[0]
            </span><span class="string">&quot;0000000000000000000000002222222222222222222222222222222222222222&quot; </span><span class="comment">// baz[1]
        </span>}
    )
}</code></pre></div>
<h3 id="udvt-and-type-aliases"><a href="#udvt-and-type-aliases">UDVT and type aliases</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::Address;
<span class="kw">use </span>alloy_sol_types::{sol, SolType};

<span class="comment">// Type definition: generates a new struct that implements `SolType`
</span><span class="macro">sol! </span>{
    <span class="kw">type </span>MyType is uint256;
}

<span class="comment">// Type aliases
</span><span class="kw">type </span>B32 = <span class="macro">sol! </span>{ bytes32 };
<span class="comment">// This is equivalent to the following:
// type B32 = alloy_sol_types::sol_data::Bytes&lt;32&gt;;

</span><span class="kw">type </span>SolArrayOf&lt;T&gt; = <span class="macro">sol! </span>{ T[] };
<span class="kw">type </span>SolTuple = <span class="macro">sol! </span>{ tuple(address, bytes, string) };

<span class="attr">#[test]
</span><span class="kw">fn </span>types() {
    <span class="kw">let _ </span>= &lt;<span class="macro">sol!</span>(bool)&gt;::encode_single(<span class="kw-2">&amp;</span><span class="bool-val">true</span>);
    <span class="kw">let _ </span>= B32::encode_single(<span class="kw-2">&amp;</span>[<span class="number">0</span>; <span class="number">32</span>]);
    <span class="kw">let _ </span>= SolArrayOf::&lt;<span class="macro">sol!</span>(bool)&gt;::encode_single(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="bool-val">true</span>, <span class="bool-val">false</span>]);
    <span class="kw">let _ </span>= SolTuple::encode_single(<span class="kw-2">&amp;</span>(Address::ZERO, <span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">32</span>], <span class="string">&quot;hello&quot;</span>.to_string()));
}</code></pre></div>
<h3 id="functions-and-errors"><a href="#functions-and-errors">Functions and errors</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{keccak256, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolCall, SolError};
<span class="kw">use </span>hex_literal::hex;

<span class="comment">// Unnamed arguments will be given a name based on their position,
// e.g. `_0`, `_1`...
//
// A current limitation for these types is that custom types, like structs,
// must be defined in the same macro scope, otherwise a signature cannot be
// generated at compile time.

</span><span class="macro">sol! </span>{
    <span class="doccomment">/// Function definitions generate two types that implement [`SolCall`]:
    /// 1. `&lt;name&gt;Call`: struct with the function arguments;
    /// 2. `&lt;name&gt;Return`: struct with the return values;
    /// where `&lt;name&gt;` is the case-preserved name of the function.
    ///
    /// In the case of overloaded functions, an underscore and the index of the
    /// function will be appended to `&lt;name&gt;` (like `foo_0`, `foo_1`...) for
    /// disambiguation, but the signature will remain the same.
    ///
    /// Both of these types will have the attributes of the function, like this
    /// doc comment, but this might change in the future.
    ///
    /// Currently, return structs should only be used for decoding data using
    /// `decode_raw`, as the generated signature is not valid.
    </span>function foo(uint256 a, uint256 b) external view returns (uint256);

    <span class="comment">// These will be interpreted as `overloaded_0`, `overloaded_1`, and
    // `overloaded_2`, but the signatures will be the same.
    </span>function overloaded();
    function overloaded(uint256) returns (uint256);
    function overloaded(string);

    <span class="doccomment">/// Implements [`SolError`].
    </span><span class="attr">#[derive(Debug, PartialEq)]
    </span>error MyError(uint256 a, uint256 b);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>function() {
    assert_call_signature::&lt;fooCall&gt;(<span class="string">&quot;foo(uint256,uint256)&quot;</span>);

    <span class="comment">// not actually a valid signature, and it shouldn&#39;t be relied upon for
    // ABI encoding
    </span>assert_call_signature::&lt;fooReturn&gt;(<span class="string">&quot;foo(uint256)&quot;</span>);

    <span class="kw">let </span>call = fooCall {
        a: U256::from(<span class="number">1</span>),
        b: U256::from(<span class="number">2</span>),
    };
    <span class="kw">let </span>_call_data = call.encode();

    <span class="comment">// the signatures are unaffected
    </span><span class="kw">let _ </span>= overloaded_0Call {};
    assert_call_signature::&lt;overloaded_0Call&gt;(<span class="string">&quot;overloaded()&quot;</span>);

    <span class="kw">let _ </span>= overloaded_1Call { _0: U256::from(<span class="number">1</span>) };
    <span class="kw">let _ </span>= overloaded_1Return { _0: U256::from(<span class="number">2</span>) };
    assert_call_signature::&lt;overloaded_1Call&gt;(<span class="string">&quot;overloaded(uint256)&quot;</span>);

    <span class="kw">let _ </span>= overloaded_2Call { _0: <span class="string">&quot;hello&quot;</span>.into() };
    assert_call_signature::&lt;overloaded_2Call&gt;(<span class="string">&quot;overloaded(string)&quot;</span>);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>error() {
    assert_error_signature::&lt;MyError&gt;(<span class="string">&quot;MyError(uint256,uint256)&quot;</span>);
    <span class="kw">let </span>call_data = <span class="macro">hex!</span>(
        <span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;
        &quot;0000000000000000000000000000000000000000000000000000000000000002&quot;
    </span>);
    <span class="macro">assert_eq!</span>(
        MyError::decode_raw(<span class="kw-2">&amp;</span>call_data, <span class="bool-val">true</span>),
        <span class="prelude-val">Ok</span>(MyError {
            a: U256::from(<span class="number">1</span>),
            b: U256::from(<span class="number">2</span>)
        })
    );
}

<span class="kw">fn </span>assert_call_signature&lt;T: SolCall&gt;(expected: <span class="kw-2">&amp;</span>str) {
    <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
    <span class="macro">assert_eq!</span>(T::SELECTOR, keccak256(expected)[..<span class="number">4</span>]);
}

<span class="kw">fn </span>assert_error_signature&lt;T: SolError&gt;(expected: <span class="kw-2">&amp;</span>str) {
    <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
    <span class="macro">assert_eq!</span>(T::SELECTOR, keccak256(expected)[..<span class="number">4</span>]);
}</code></pre></div>
<h3 id="events"><a href="#events">Events</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#![allow(clippy::assertions_on_constants)]

</span><span class="kw">use </span>alloy_primitives::{keccak256, B256, U256};
<span class="kw">use </span>alloy_sol_types::{sol, token::WordToken, SolEvent};
<span class="kw">use </span>hex_literal::hex;

<span class="macro">sol! </span>{
    <span class="attr">#[derive(Default)]
    </span>event MyEvent(bytes32 indexed a, uint256 b, string indexed c, bytes d);

    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;

    <span class="kw">struct </span>Data {
        bytes data;
    }
    event MyEvent2(Data indexed data);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>event() {
    assert_event_signature::&lt;MyEvent&gt;(<span class="string">&quot;MyEvent(bytes32,uint256,string,bytes)&quot;</span>);
    <span class="macro">assert!</span>(!MyEvent::ANONYMOUS);
    <span class="kw">let </span>event = MyEvent {
        a: [<span class="number">0x11</span>; <span class="number">32</span>],
        b: U256::from(<span class="number">1u64</span>),
        c: keccak256(<span class="string">&quot;Hello World&quot;</span>).into(),
        d: Vec::new(),
    };
    <span class="comment">// topics are `(SELECTOR, a, keccak256(c))`
    </span><span class="macro">assert_eq!</span>(
        event.encode_topics_array::&lt;<span class="number">3</span>&gt;(),
        [
            WordToken(MyEvent::SIGNATURE_HASH),
            WordToken(B256::repeat_byte(<span class="number">0x11</span>)),
            WordToken(keccak256(<span class="string">&quot;Hello World&quot;</span>))
        ]
    );
    <span class="comment">// dynamic data is `abi.encode(b, d)`
    </span><span class="macro">assert_eq!</span>(
        event.encode_data(),
        <span class="macro">hex!</span>(
            <span class="comment">// b
            </span><span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;
            </span><span class="comment">// d offset
            </span><span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000040&quot;
            </span><span class="comment">// d length
            </span><span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
        </span>),
    );

    assert_event_signature::&lt;LogNote&gt;(<span class="string">&quot;LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)&quot;</span>);
    <span class="macro">assert!</span>(LogNote::ANONYMOUS);

    assert_event_signature::&lt;MyEvent2&gt;(<span class="string">&quot;MyEvent2((bytes))&quot;</span>);
    <span class="macro">assert!</span>(!MyEvent2::ANONYMOUS);
}

<span class="kw">fn </span>assert_event_signature&lt;T: SolEvent&gt;(expected: <span class="kw-2">&amp;</span>str) {
    <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
    <span class="macro">assert_eq!</span>(T::SIGNATURE_HASH, keccak256(expected));
}</code></pre></div>
<h3 id="contractsinterfaces"><a href="#contractsinterfaces">Contracts/interfaces</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{Address, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolCall};
<span class="kw">use </span>hex_literal::hex;

<span class="macro">sol! </span>{
    <span class="doccomment">/// Interface of the ERC20 standard as defined in [the EIP].
    ///
    /// [the EIP]: https://eips.ethereum.org/EIPS/eip-20
    </span><span class="attr">#[derive(Debug, PartialEq)]
    </span>interface IERC20 {
        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);

        function totalSupply() external view returns (uint256);
        function balanceOf(address account) external view returns (uint256);
        function transfer(address to, uint256 amount) external returns (bool);
        function allowance(address owner, address spender) external view returns (uint256);
        function approve(address spender, uint256 amount) external returns (bool);
        function transferFrom(address from, address to, uint256 amount) external returns (bool);
    }
}

<span class="attr">#[test]
</span><span class="kw">fn </span>contracts() {
    <span class="comment">// random mainnet ERC20 transfer
    // https://etherscan.io/tx/0x947332ff624b5092fb92e8f02cdbb8a50314e861a4b39c29a286b3b75432165e
    </span><span class="kw">let </span>data = <span class="macro">hex!</span>(
        <span class="string">&quot;a9059cbb&quot;
        &quot;0000000000000000000000008bc47be1e3abbaba182069c89d08a61fa6c2b292&quot;
        &quot;0000000000000000000000000000000000000000000000000000000253c51700&quot;
    </span>);
    <span class="kw">let </span>expected = IERC20::transferCall {
        to: Address::from(<span class="macro">hex!</span>(<span class="string">&quot;8bc47be1e3abbaba182069c89d08a61fa6c2b292&quot;</span>)),
        amount: U256::from(<span class="number">9995360000_u64</span>),
    };

    <span class="macro">assert_eq!</span>(data[..<span class="number">4</span>], IERC20::transferCall::SELECTOR);
    <span class="kw">let </span>decoded = IERC20::IERC20Calls::decode(<span class="kw-2">&amp;</span>data, <span class="bool-val">true</span>).unwrap();
    <span class="macro">assert_eq!</span>(decoded, IERC20::IERC20Calls::transfer(expected));
    <span class="macro">assert_eq!</span>(decoded.encode(), data);
}</code></pre></div>
</div></details></section></div></main></body></html>