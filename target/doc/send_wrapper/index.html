<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This Rust library implements a wrapper type called `SendWrapper` which allows you to move around non-`Send` types between threads, as long as you access the contained value only from within the original thread. You also have to make sure that the wrapper is dropped from within the original thread. If any of these constraints is violated, a panic occurs. `SendWrapper&lt;T&gt;` implements `Send` and `Sync` for any type `T`."><title>send_wrapper - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="send_wrapper" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../send_wrapper/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../send_wrapper/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate send_wrapper</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">send_wrapper</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/send_wrapper/lib.rs.html#9-353">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This <a href="https://www.rust-lang.org">Rust</a> library implements a wrapper type called <code>SendWrapper</code> which allows you to move around non-<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> types
between threads, as long as you access the contained value only from within the original thread. You also have to
make sure that the wrapper is dropped from within the original thread. If any of these constraints is violated,
a panic occurs. <code>SendWrapper&lt;T&gt;</code> implements <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> for any type <code>T</code>.</p>
<p>The idea for this library was born in the context of a <a href="https://www.gtk.org/"><code>GTK+</code></a>/<a href="http://gtk-rs.org/"><code>gtk-rs</code></a>-based application. <a href="https://www.gtk.org/"><code>GTK+</code></a> applications
are strictly single-threaded. It is not allowed to call any <a href="https://www.gtk.org/"><code>GTK+</code></a> method from a thread different to the main
thread. Consequently, all <a href="http://gtk-rs.org/"><code>gtk-rs</code></a> structs are non-<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>.</p>
<p>Sometimes you still want to do some work in background. It is possible to enqueue <a href="https://www.gtk.org/"><code>GTK+</code></a> calls from there to be
executed in the main thread <a href="http://gtk-rs.org/docs/glib/source/fn.idle_add.html">using <code>Glib</code></a>. This way you can know, that the <a href="http://gtk-rs.org/"><code>gtk-rs</code></a> structs involved are only
accessed in the main thread and will also be dropped there. This library makes it possible that <a href="http://gtk-rs.org/"><code>gtk-rs</code></a> structs
can leave the main thread at all.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>send_wrapper::SendWrapper;
<span class="kw">use </span>std::rc::Rc;
<span class="kw">use </span>std::thread;
<span class="kw">use </span>std::sync::mpsc::channel;

<span class="comment">// This import is important. It allows you to unwrap the value using deref(),
// deref_mut() or Deref coercion.
</span><span class="kw">use </span>std::ops::{Deref, DerefMut};

<span class="comment">// Rc is a non-Send type.
</span><span class="kw">let </span>value = Rc::new(<span class="number">42</span>);

<span class="comment">// We now wrap the value with `SendWrapper` (value is moved inside).
</span><span class="kw">let </span>wrapped_value = SendWrapper::new(value);

<span class="comment">// A channel allows us to move the wrapped value between threads.
</span><span class="kw">let </span>(sender, receiver) = channel();

<span class="kw">let </span>t = thread::spawn(<span class="kw">move </span>|| {

<span class="comment">// This would panic (because of dereferencing in wrong thread):
// let value = wrapped_value.deref();

	// Move SendWrapper back to main thread, so it can be dropped from there.
	// If you leave this out the thread will panic because of dropping from wrong thread.
	</span>sender.send(wrapped_value).unwrap();

});

<span class="kw">let </span>wrapped_value = receiver.recv().unwrap();

<span class="comment">// Now you can use the value again.
</span><span class="kw">let </span>value = wrapped_value.deref();

<span class="comment">// alternatives for dereferencing:
// let value = *wrapped_value;
// let value: &amp;NonSendType = &amp;wrapped_value;

// alternatives for mutable dereferencing (value and wrapped_value must be mutable too, then):
// let mut value = wrapped_value.deref_mut();
// let mut value = &amp;mut *wrapped_value;
// let mut value: &amp;mut NonSendType = &amp;mut wrapped_value;</span></code></pre></div>
<h2 id="license"><a href="#license">License</a></h2>
<p><code>send_wrapper</code> is distributed under the terms of both the MIT license and the Apache License (Version 2.0).</p>
<p>See LICENSE-APACHE.txt, and LICENSE-MIT.txt for details.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.SendWrapper.html" title="struct send_wrapper::SendWrapper">SendWrapper</a></div><div class="desc docblock-short">A wrapper which allows you to move around non-<a href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a>-types between threads, as long as you access the contained
value only from within the original thread and make sure that it is dropped from within the original thread.</div></li></ul></section></div></main></body></html>